name: Validar solicitação com Gemini 2.0 Flash e criar issue

on:
  issues:
    types: [opened, labeled]

permissions:
  issues: write
  contents: read

jobs:
  gatekeep:
    runs-on: ubuntu-latest
    # roda se já veio com a label ao abrir, OU se acabou de rotular com 'solicitacao'
    if: >
      contains(github.event.issue.labels.*.name, 'solicitacao') ||
      (github.event.action == 'labeled' && github.event.label.name == 'solicitacao')

    steps:
      - name: Extrair campos do formulário
        id: parse
        run: |
          BODY=$(printf "%s" "${{ github.event.issue.body }}")

          extrair() {
            echo "$BODY" | awk -v header="### $1" '
              $0==header {flag=1; next}
              /^### / && flag {flag=0}
              flag {print}
            ' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//'
          }

          TITULO=$(extrair "Título sugerido" | head -n 1)
          PROBLEMA=$(extrair "Descrição / Problema")
          PASSOS=$(extrair "Passos para reproduzir (se bug)")
          CRITERIO=$(extrair "Critérios de aceite")
          DESTINO=$(extrair "Repositório de destino" | head -n 1)

          echo "titulo=$TITULO" >> $GITHUB_OUTPUT
          echo "problema<<EOF" >> $GITHUB_OUTPUT
          echo "$PROBLEMA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "passos<<EOF" >> $GITHUB_OUTPUT
          echo "$PASSOS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "criterio<<EOF" >> $GITHUB_OUTPUT
          echo "$CRITERIO" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "destino=$DESTINO" >> $GITHUB_OUTPUT

      - name: Validar com Gemini 2.0 Flash (JSON estrito)
        id: gemini
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          # 1) Defina o schema de saída (obriga o JSON)
          read -r -d '' SCHEMA << 'JSON'
          {
            "type": "object",
            "properties": {
              "aprovado": { "type": "boolean" },
              "motivos":  { "type": "array", "items": { "type": "string" } },
              "titulo_corrigido": { "type": ["string", "null"] },
              "observacoes": { "type": ["string", "null"] }
            },
            "required": ["aprovado", "motivos"],
            "additionalProperties": false
          }
          JSON

          # 2) System instruction: papel + regras
          read -r -d '' SYS << 'TXT'
          Você é um revisor de qualidade de backlog. Avalie a solicitação de issue
          pedindo: título claro (< 80 chars), problema com contexto/impacto, passos (se bug),
          e critérios de aceite mensuráveis. Responda SOMENTE no schema JSON definido.
          TXT

          # 3) Prompt com os dados do formulário
          read -r -d '' USER << 'TXT'
          Título: ${{ steps.parse.outputs.titulo }}
          Problema:
          ${{ steps.parse.outputs.problema }}

          Passos:
          ${{ steps.parse.outputs.passos }}

          Critérios de aceite:
          ${{ steps.parse.outputs.criterio }}
          TXT

          # 4) Monta o payload do Gemini API
          PAYLOAD=$(jq -n \
            --arg sys "$SYS" \
            --arg user "$USER" \
            --argjson schema "$SCHEMA" \
            '{
              system_instruction: { text: $sys },
              contents: [{ role: "user", parts: [{text: $user}]}],
              generationConfig: {
                response_mime_type: "application/json",
                response_schema: $schema,
                temperature: 0.2
              }
            }'
          )

          # 5) Chama o endpoint v1beta generateContent para o modelo 2.0 Flash
          RESP=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GOOGLE_API_KEY" \
            -d "$PAYLOAD")

          # 6) Extrai o JSON retornado (vem em candidates[0].content.parts[0].text)
          TEXT=$(echo "$RESP" | jq -r '.candidates[0].content.parts[0].text // ""')
          echo "$TEXT" | jq . > gemini.json

          APROVADO=$(jq -r '.aprovado' gemini.json)
          TITULO_CORRIGIDO=$(jq -r '.titulo_corrigido' gemini.json)

          echo "aprovado=$APROVADO" >> $GITHUB_OUTPUT
          echo "titulo_ok=$TITULO_CORRIGIDO" >> $GITHUB_OUTPUT

      - name: Criar issue no repositório de destino (se aprovado)
        if: steps.gemini.outputs.aprovado == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }} # PAT com escopo repo
          DEST: ${{ steps.parse.outputs.destino }}
        run: |
          TITLE="${{ steps.gemini.outputs.titulo_ok }}"
          if [ -z "$TITLE" ] || [ "$TITLE" = "null" ]; then
            TITLE="${{ steps.parse.outputs.titulo }}"
          fi

          BODY="**Problema**:\n${{ steps.parse.outputs.problema }}\n\n**Passos**:\n${{ steps.parse.outputs.passos }}\n\n**Critérios de aceite**:\n${{ steps.parse.outputs.criterio }}\n\n_Criada automaticamente após aprovação (Gemini 2.0 Flash)._"

          OWNER=${DEST%%/*}
          REPO=${DEST#*/}

          gh api repos/$OWNER/$REPO/issues \
            -f title="$TITLE" \
            -f body="$BODY"

      - name: Comentar e fechar solicitação (se reprovado)
        if: steps.gemini.outputs.aprovado != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const j = JSON.parse(fs.readFileSync('gemini.json','utf8'))
            const motivos = (j.motivos || []).map(m => `- ${m}`).join('\n')
            const obs = j.observacoes ? `\n\n**Sugestões:**\n${j.observacoes}\n` : ''
            const body = `A solicitação **não foi aprovada** pela validação automática.\n\n**Motivos:**\n${motivos}${obs}\n_Reveja e reabra com as correções._`
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            })
