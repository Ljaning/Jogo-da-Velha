name: Validar solicita√ß√£o com Gemini 2.5 Flash e criar issue

on:
  issues:
    types: [opened, labeled]

# (Opcional) evita duplica√ß√£o quando abrir + rotular quase ao mesmo tempo
concurrency:
  group: intake-${{ github.event.issue.node_id }}
  cancel-in-progress: true

permissions:
  issues: write
  contents: read

jobs:
  gatekeep:
    runs-on: ubuntu-latest
    # s√≥ roda se a issue j√° veio com a label 'solicitacao'
    # ou se o evento atual foi rotular com 'solicitacao'
    if: >
      contains(github.event.issue.labels.*.name, 'solicitacao') ||
      (github.event.action == 'labeled' && github.event.label.name == 'solicitacao')
    env:
      # üëá modelo centralizado aqui; troque se necess√°rio (ex.: gemini-2.5-flash-001)
      GEMINI_MODEL: gemini-2.5-flash

    steps:
      - name: Debug do evento
        run: |
          echo "action: ${{ github.event.action }}"
          echo "label (se for labeled): ${{ github.event.label.name }}"
          echo "labels atuais: ${{ toJson(github.event.issue.labels) }}"
          echo "body (in√≠cio):"
          echo "${{ github.event.issue.body }}" | head -n 40

      - name: Extrair campos do formul√°rio (novos cabe√ßalhos)
        id: parse
        run: |
          BODY=$(printf "%s" "${{ github.event.issue.body }}")

          extrair() {
            # Busca blocos estilo: "### <Label>\n<valor ... at√© pr√≥ximo ###>"
            echo "$BODY" | awk -v header="### $1" '
              $0==header {flag=1; next}
              /^### / && flag {flag=0}
              flag {print}
            ' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//'
          }

          DESCRICAO=$(extrair "Descri√ß√£o do Bug")
          LOCALIZACAO=$(extrair "Localiza√ß√£o")
          PASSOS=$(extrair "Passos para Reprodu√ß√£o")
          EVIDENCIAS=$(extrair "Evid√™ncias")
          RESULTADO=$(extrair "Resultado Esperado")
          DESTINO=$(extrair "Reposit√≥rio de destino" | head -n 1)

          # T√≠tulo base: 1¬™ linha da descri√ß√£o (ser√° limitado a 7 palavras mais √† frente)
          TITULO=$(printf "%s" "$DESCRICAO" | sed -n '1p' | sed 's/#\+//g; s/\r//g')
          if [ -z "$TITULO" ]; then TITULO="Bug report"; fi

          {
            echo "descricao<<EOF";   echo "$DESCRICAO";   echo "EOF";
            echo "localizacao<<EOF"; echo "$LOCALIZACAO"; echo "EOF";
            echo "passos<<EOF";      echo "$PASSOS";      echo "EOF";
            echo "evidencias<<EOF";  echo "$EVIDENCIAS";  echo "EOF";
            echo "resultado<<EOF";   echo "$RESULTADO";   echo "EOF";
            echo "destino=$DESTINO";
            echo "titulo=$TITULO";
          } >> $GITHUB_OUTPUT

      # ===================== PR√â-VALIDA√á√ÉO (regras objetivas) =====================
      - name: Pr√©-valida√ß√£o determin√≠stica
        id: precheck
        run: |
          fail() { echo "$1" >> precheck_errors.txt; }

          DESC="${{ steps.parse.outputs.descricao }}"
          LOC="${{ steps.parse.outputs.localizacao }}"
          PASS="${{ steps.parse.outputs.passos }}"
          EVID="${{ steps.parse.outputs.evidencias }}"
          RES="${{ steps.parse.outputs.resultado }}"

          # 0) Tamanho total (todas as respostas) ‚â§ 450 caracteres
          TOTLEN=$(printf "%s%s%s%s%s" "$DESC" "$LOC" "$PASS" "$EVID" "$RES" | wc -c)
          [ "$TOTLEN" -gt 450 ] && fail "Texto total ultrapassa 450 caracteres (atual: ${TOTLEN})."

          # 1) Descri√ß√£o: no m√°ximo 2 frases (conta . ! ?)
          SENT=$(printf "%s" "$DESC" | tr '\n' ' ' | grep -oE '[.!?]' | wc -l || true)
          [ "$SENT" -gt 2 ] && fail "Descri√ß√£o do Bug deve ter no m√°ximo 2 frases com contexto (como/quando)."

          # 2) Localiza√ß√£o: pelo menos 1 n√≠vel (n√£o vazia)
          [ -z "$(printf "%s" "$LOC" | tr -d '[:space:]')" ] && \
            fail "Localiza√ß√£o obrigat√≥ria; informe o caminho/tela (ex.: Tela principal > Tabuleiro)."

          # 3) Passos: numerados e no m√≠nimo 2
          CNT=$(printf "%s" "$PASS" | grep -E '^[[:space:]]*[0-9]+[.)]' | wc -l || true)
          [ "$CNT" -lt 2 ] && fail "Passos para Reprodu√ß√£o devem ser numerados (1), 2), ...) e ter no m√≠nimo 2 passos."

          # 4) Evid√™ncias: pelo menos 1 URL ou anexo (markdown imagem/arquivo)
          printf "%s" "$EVID" | grep -Eiq '!\[[^]]*\]\(|https?://|\.png|\.jpg|\.jpeg|\.gif|\.mp4|\.mov' || \
            fail "Evid√™ncias devem conter ao menos 1 URL (print/v√≠deo) ou arquivo anexado."

          # 5) Resultado: rejeitar gen√©ricos
          printf "%s" "$RES" | grep -Eiq 'funcion(a|e) corretamente|sem erro(s)?|deveria funcionar|ok' && \
            fail "Resultado esperado est√° gen√©rico; descreva comportamento espec√≠fico e verific√°vel."

          # 6) PII/segredos (heur√≠stica simples)
          printf "%s %s %s" "$DESC" "$EVID" "$PASS" | \
          grep -Eiq '(AKIA[0-9A-Z]{16}|-----BEGIN (RSA|OPENSSH) PRIVATE KEY-----|password=|secret=|x-api-key|token=|Authorization: Bearer)' && {
            echo "escalar=true" >> $GITHUB_OUTPUT
            fail "Poss√≠vel dado sens√≠vel detectado (chaves/senhas/segredos); remova ou redija."
          }

          if [ -f precheck_errors.txt ]; then
            echo "found_errors=true" >> $GITHUB_OUTPUT
          else
            echo "found_errors=false" >> $GITHUB_OUTPUT
          fi

      - name: Reprovar por pr√©-valida√ß√£o
        if: steps.precheck.outputs.found_errors == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const fs = require('fs')
            const raw = fs.readFileSync('precheck_errors.txt','utf8')
            const motivos = raw.split('\n').filter(Boolean)

            // Sugest√µes curtas e espec√≠ficas
            const sug = motivos.map(m => {
              if (m.includes('Texto total ultrapassa')) return '- Reduza as respostas para no m√°ximo 450 caracteres.'
              if (m.includes('no m√°ximo 2 frases')) return '- Reescreva a descri√ß√£o em at√© 2 frases com contexto (como/quando ocorreu).'
              if (m.includes('Localiza√ß√£o obrigat√≥ria')) return '- Informe o caminho/tela. Ex.: Tela principal > Tabuleiro.'
              if (m.includes('Passos para Reprodu√ß√£o')) return '- Liste pelo menos 2 passos numerados (1), 2), ...).'
              if (m.includes('Evid√™ncias devem')) return '- Inclua ao menos 1 link de print/v√≠deo ou anexe um arquivo.'
              if (m.includes('Resultado esperado est√° gen√©rico')) return '- Descreva o comportamento correto verific√°vel (ex.: ‚Äúlimpar c√©lulas e resetar o contador‚Äù).'
              if (m.includes('Poss√≠vel dado sens√≠vel')) return '- Remova chaves/senhas/segredos e substitua por <redigido>.'
              return `- ${m}`
            })

            const bullets = motivos.map(x => `- ${x}`).join('\n')
            const sugestoes = sug.join('\n')
            const body =
`A solicita√ß√£o n√£o foi aprovada pela valida√ß√£o autom√°tica.

**Motivos:**
${bullets}

**Sugest√µes:**
${sugestoes}

Reveja e reabra com as corre√ß√µes.`

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            })

      # ======================== VALIDA√á√ÉO COM GEMINI 2.5 =========================
      - name: Validar com Gemini 2.5 Flash (JSON estrito)
        id: gemini
        if: steps.precheck.outputs.found_errors == 'false'
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GEMINI_MODEL: ${{ env.GEMINI_MODEL }}
        run: |
          SCHEMA=$(cat <<'JSON'
          {
            "type": "OBJECT",
            "properties": {
              "aprovado": { "type": "BOOLEAN" },
              "escalar":  { "type": "BOOLEAN" },
              "score":    { "type": "NUMBER" },
              "motivos":  { "type": "ARRAY", "items": { "type": "STRING" } },
              "sugestoes":{ "type": "ARRAY", "items": { "type": "STRING" } },
              "titulo_corrigido": { "type": "STRING" }
            },
            "required": ["aprovado","escalar","motivos"]
          }
          JSON
          )

          SYS=$(cat <<'TXT'
          Voc√™ √© um revisor de qualidade de bugs. Linguagem: Portugu√™s (Brasil). Seja objetivo e claro.
          Aprove SOMENTE se TODAS as regras forem atendidas:
          - T√≠tulo: at√© 7 palavras (conciso, preserva contexto).
          - Descri√ß√£o: at√© 2 frases com contexto (como e quando).
          - Localiza√ß√£o: tem ao menos 1 n√≠vel.
          - Passos: numerados, pelo menos 2 passos.
          - Evid√™ncias: cont√©m ao menos 1 URL ou anexo.
          - Resultado: espec√≠fico e verific√°vel (n√£o gen√©rico).
          - Sem PII/segredos; se houver ‚Üí escalar=true e reprove.
          O que voc√™ N√ÉO deve fazer: estimar esfor√ßo, priorizar, sugerir solu√ß√£o t√©cnica ou culpados.
          Responda SOMENTE no schema JSON. Preencha "motivos" e "sugestoes" como bullets curtos e diretos.
          Se poss√≠vel, proponha "titulo_corrigido" (<= 7 palavras).
          TXT
          )

          USER=$(cat <<'TXT'
          Descri√ß√£o do Bug:
          ${{ steps.parse.outputs.descricao }}

          Localiza√ß√£o:
          ${{ steps.parse.outputs.localizacao }}

          Passos para Reprodu√ß√£o:
          ${{ steps.parse.outputs.passos }}

          Evid√™ncias:
          ${{ steps.parse.outputs.evidencias }}

          Resultado Esperado:
          ${{ steps.parse.outputs.resultado }}
          TXT
          )

          PAYLOAD=$(jq -n \
            --arg sys "$SYS" \
            --arg user "$USER" \
            --argjson schema "$SCHEMA" \
            '{
              system_instruction: { role: "system", parts: [ { text: $sys } ] },
              contents: [ { role: "user", parts: [ { text: $user } ] } ],
              generationConfig: {
                response_mime_type: "application/json",
                response_schema: $schema,
                temperature: 0.1
              }
            }'
          )

          HTTP=$(curl -sS -w "%{http_code}" -o resp.json \
            -X POST "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GOOGLE_API_KEY" \
            -d "$PAYLOAD")

          echo "HTTP status: $HTTP"
          if [ "$HTTP" -lt 200 ] || [ "$HTTP" -ge 300 ]; then echo "Erro:"; cat resp.json; exit 1; fi

          TEXT=$(jq -r '.candidates[0].content.parts[0].text // empty' resp.json)
          [ -z "$TEXT" ] && { echo "Sem texto"; cat resp.json; exit 1; }
          echo "$TEXT" | jq . > gemini.json || { echo "$TEXT"; exit 1; }

          APROVADO=$(jq -r '.aprovado' gemini.json)
          ESCALAR=$(jq -r '.escalar' gemini.json)
          TITULO_CORRIGIDO=$(jq -r '.titulo_corrigido // empty' gemini.json)

          if [ "$ESCALAR" = "true" ]; then APROVADO=false; fi
          echo "aprovado=$APROVADO" >> $GITHUB_OUTPUT
          echo "titulo_ok=$TITULO_CORRIGIDO" >> $GITHUB_OUTPUT

      # ============================ APROVADO =============================
      - name: Criar issue no reposit√≥rio de destino (se aprovado)
        if: steps.gemini.outputs.aprovado == 'true'
        id: create_issue
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          DEST: ${{ steps.parse.outputs.destino }}
        run: |
          # 1) T√≠tulo vindo do Gemini ou da 1¬™ linha da descri√ß√£o
          RAW="${{ steps.gemini.outputs.titulo_ok }}"
          if [ -z "$RAW" ] || [ "$RAW" = "null" ]; then
            RAW="$(printf "%s" "${{ steps.parse.outputs.titulo }}")"
          fi
          # 2) Limita a 7 palavras
          TITLE=$(printf "%s\n" "$RAW" | awk '{ n=7; for(i=1;i<=NF && i<=n;i++) printf("%s%s",$i,(i==n||i==NF)?"":" "); print "" }')

          BODY="**Descri√ß√£o do Bug**:\n${{ steps.parse.outputs.descricao }}\n\n**Localiza√ß√£o**:\n${{ steps.parse.outputs.localizacao }}\n\n**Passos para Reprodu√ß√£o**:\n${{ steps.parse.outputs.passos }}\n\n**Evid√™ncias**:\n${{ steps.parse.outputs.evidencias }}\n\n**Resultado Esperado**:\n${{ steps.parse.outputs.resultado }}\n\n_Criada automaticamente ap√≥s aprova√ß√£o (Gemini 2.5 Flash)._"

          OWNER=${DEST%%/*}
          REPO=${DEST#*/}

          RESP=$(gh api repos/$OWNER/$REPO/issues -f title="$TITLE" -f body="$BODY")
          echo "$RESP" | jq -r '.html_url' > created_url.txt
          echo "url=$(cat created_url.txt)" >> $GITHUB_OUTPUT

      - name: Comentar link e fechar solicita√ß√£o (se aprovado)
        if: steps.gemini.outputs.aprovado == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const fs = require('fs')
            const url = fs.readFileSync('created_url.txt','utf8').trim()
            const body = `‚úÖ **Aprovada** e criada no destino:\n${url}\n\nFechando esta solicita√ß√£o.`
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            })

      # ============================ REPROVADO ============================
      - name: Comentar e fechar solicita√ß√£o (se reprovado)
        if: steps.precheck.outputs.found_errors == 'false' && steps.gemini.outputs.aprovado != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const fs = require('fs')
            const j = JSON.parse(fs.readFileSync('gemini.json','utf8'))
            const motivos = (j.motivos || []).map(m => `- ${m}`).join('\n') || '- N√£o informado.'
            const sugestoes = (j.sugestoes || []).map(s => `- ${s}`).join('\n') || '- Ajuste os campos obrigat√≥rios conforme os motivos.'
            const body =
`A solicita√ß√£o n√£o foi aprovada pela valida√ß√£o autom√°tica.

**Motivos:**
${motivos}

**Sugest√µes:**
${sugestoes}

Reveja e reabra com as corre√ß√µes.`
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            })
