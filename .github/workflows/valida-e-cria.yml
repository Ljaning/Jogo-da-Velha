name: Validar solicitação com Gemini 2.5 Flash e criar issue

on:
  issues:
    types: [opened]

concurrency:
  group: intake-${{ github.event.issue.node_id }}
  cancel-in-progress: true

permissions:
  issues: write
  contents: read

jobs:
  gatekeep:
    runs-on: ubuntu-latest
    env:
      GEMINI_MODEL: gemini-2.5-flash
      GH_TOKEN: ${{ secrets.GH_PAT }} # PAT com Projects:RW e Issues:RW
      ORG: Ljaning
      PROJECT_TITLE: projeto-teste

    steps:
      - name: Debug do evento
        run: |
          echo "issue: ${{ github.event.issue.html_url }}"
          echo "labels: ${{ toJson(github.event.issue.labels) }}"

      # 1) Adiciona ao Project v2 e seta Status=Triage (query única p/ Project + Status/Triage/Backlog)
      - name: Adicionar ao Project e setar Status=Triage
        id: pitem
        env:
          ISSUE_NODE: ${{ github.event.issue.node_id }}
        run: |
          set -Eeuo pipefail

          JSON=$(gh api graphql -f query='
            query($org:String!){
              organization(login:$org){
                projectsV2(first:100){
                  nodes{
                    id title
                    fields(first:100){
                      nodes{
                        ... on ProjectV2SingleSelectField{
                          id name
                          options{ id name }
                        }
                      }
                    }
                  }
                }
              }
            }' -f org="$ORG")

          PROJECT_ID=$(printf "%s" "$JSON" | jq -r --arg t "$PROJECT_TITLE" '.data.organization.projectsV2.nodes[] | select(.title==$t) | .id')
          [ -z "$PROJECT_ID" ] && { echo "Projeto \"$PROJECT_TITLE\" não encontrado na organização $ORG." >&2; exit 1; }

          STATUS_FIELD_ID=$(printf "%s" "$JSON" | jq -r --arg t "$PROJECT_TITLE" '
            .data.organization.projectsV2.nodes[] | select(.title==$t)
            | .fields.nodes[] | select(.name=="Status") | .id')
          TRIAGE_OPT=$(printf "%s" "$JSON" | jq -r --arg t "$PROJECT_TITLE" '
            .data.organization.projectsV2.nodes[] | select(.title==$t)
            | .fields.nodes[] | select(.name=="Status") | .options[] | select(.name=="Triage") | .id')
          BACKLOG_OPT=$(printf "%s" "$JSON" | jq -r --arg t "$PROJECT_TITLE" '
            .data.organization.projectsV2.nodes[] | select(.title==$t)
            | .fields.nodes[] | select(.name=="Status") | .options[] | select(.name=="Backlog") | .id')

          [ -z "$STATUS_FIELD_ID" ] || [ -z "$TRIAGE_OPT" ] || [ -z "$BACKLOG_OPT" ] && {
            echo "Campo 'Status' e/ou opções 'Triage'/'Backlog' não encontrados."; exit 1; }

          ITEM_ID=$(gh api graphql -f query='
            mutation($pid:ID!, $cid:ID!){
              addProjectV2ItemById(input:{projectId:$pid, contentId:$cid}){ item { id } }
            }' -f pid="$PROJECT_ID" -f cid="$ISSUE_NODE" | jq -r '.data.addProjectV2ItemById.item.id')
          [ -z "$ITEM_ID" ] && { echo "Falha ao adicionar a issue como item do projeto." >&2; exit 1; }

          gh api graphql -f query='
            mutation($project:ID!, $item:ID!, $field:ID!, $opt:String!){
              updateProjectV2ItemFieldValue(input:{
                projectId:$project, itemId:$item, fieldId:$field,
                value:{ singleSelectOptionId:$opt }
              }){ clientMutationId }
            }' \
            -f project="$PROJECT_ID" -f item="$ITEM_ID" -f field="$STATUS_FIELD_ID" -f opt="$TRIAGE_OPT" >/dev/null

          echo "project_id=$PROJECT_ID"       >> $GITHUB_OUTPUT
          echo "item_id=$ITEM_ID"             >> $GITHUB_OUTPUT
          echo "status_field_id=$STATUS_FIELD_ID" >> $GITHUB_OUTPUT
          echo "backlog_opt=$BACKLOG_OPT"     >> $GITHUB_OUTPUT

      # 2) Extrair campos do formulário
      - name: Extrair campos do formulário
        id: parse
        run: |
          set -Eeuo pipefail
          BODY=$(printf "%s" "${{ github.event.issue.body }}")

          extrair(){ awk -v h="$1" 'BEGIN{pat="^[[:space:]]*### "h"[[:space:]]*$"} $0~pat{f=1;next} /^[[:space:]]*### [^#]/{f=0} f{print}' <<<"$BODY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' ;}
          extrair_nn(){ extrair "$1" | awk 'NF{print;exit}'; }
          extrair_bold(){ awk -v l="$1" 'BEGIN{pat="^[[:space:]]*\\*\\*[[:space:]]*"l"[[:space:]]*\\*\\*[[:space:]]*$"} $0~pat{while(getline){if($0!~/^[[:space:]]*$/){print;exit}}}' <<<"$BODY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'; }

          DESC="$(extrair "Descrição do Bug")"
          LOC="$(extrair "Localização")"
          PASSOS="$(extrair "Passos para Reprodução")"
          EVID="$(extrair "Evidências")"
          RES="$(extrair "Resultado Esperado")"

          DEST="$(extrair_nn "Repositório de destino")"
          [ -z "$DEST" ] && DEST="$(extrair_nn "Destino")"
          [ -z "$DEST" ] && DEST="$(extrair_nn "Target repository")"
          [ -z "$DEST" ] && DEST="$(extrair_nn "Repositório")"
          [ -z "$DEST" ] && DEST="$(extrair_bold "Repositório de destino")"
          [ -z "$DEST" ] && DEST="$(extrair_bold "Destino")"
          [ -z "$DEST" ] && DEST="$(extrair_bold "Target repository")"
          [ -z "$DEST" ] && DEST="$(extrair_bold "Repositório")"

          echo "::group::DEBUG parse"; echo "Destino extraído: '$DEST'"; echo "::endgroup::"

          {
            echo "descricao<<EOF"; printf "%s\n" "$DESC"; echo "EOF"
            echo "localizacao<<EOF"; printf "%s\n" "$LOC"; echo "EOF"
            echo "passos<<EOF"; printf "%s\n" "$PASSOS"; echo "EOF"
            echo "evidencias<<EOF"; printf "%s\n" "$EVID"; echo "EOF"
            echo "resultado<<EOF"; printf "%s\n" "$RES"; echo "EOF"
            echo "destino=$DEST"
          } >> "$GITHUB_OUTPUT"

      # 3) Pré-validação determinística
      - name: Pré-validação
        id: precheck
        run: |
          set -Eeuo pipefail
          fail(){ echo "$1" >> precheck_errors.txt; }

          DESC="${{ steps.parse.outputs.descricao }}"
          LOC="${{ steps.parse.outputs.localizacao }}"
          PASS="${{ steps.parse.outputs.passos }}"
          EVID="${{ steps.parse.outputs.evidencias }}"
          RES="${{ steps.parse.outputs.resultado }}"
          DEST="${{ steps.parse.outputs.destino }}"

          TOTLEN=$(printf "%s%s%s%s%s" "$DESC" "$LOC" "$PASS" "$EVID" "$RES" | wc -c)
          [ "$TOTLEN" -gt 800 ] && fail "Texto total ultrapassa 800 caracteres (atual: ${TOTLEN})."

          SENT=$(printf "%s" "$DESC" | tr '\n' ' ' | grep -oE '[.!?]' | wc -l || true)
          [ "$SENT" -gt 2 ] && fail "Descrição do Bug deve ter no máximo 2 frases com contexto (como/quando)."

          [ -z "$(printf "%s" "$LOC" | tr -d '[:space:]')" ] && fail "Localização obrigatória; informe o caminho/tela (ex.: Tela principal > Tabuleiro)."

          CNT=$(printf "%s\n" "$PASS" | grep -Ec '^[[:space:]]*[0-9]+[.)]')
          [ "$CNT" -lt 2 ] && fail "Passos para Reprodução devem ser numerados (1), 2), ...) e ter no mínimo 2 passos."

          printf "%s" "$EVID" | grep -Eiq '!\[[^]]*\]\(|https?://|\.png|\.jpe?g|\.gif|\.mp4|\.mov' || \
            fail "Evidências devem conter ao menos 1 URL (print/vídeo) ou arquivo anexado."

          printf "%s" "$RES" | grep -Eiq 'funcion(a|e) corretamente|sem erro(s)?|deveria funcionar|ok' && \
            fail "Resultado esperado está genérico; descreva comportamento específico e verificável."

          printf "%s %s %s" "$DESC" "$EVID" "$PASS" | \
          grep -Eiq '(AKIA[0-9A-Z]{16}|-----BEGIN (RSA|OPENSSH) PRIVATE KEY-----|password=|secret=|x-api-key|token=|Authorization: Bearer)' && {
            echo "escalar=true" >> $GITHUB_OUTPUT
            fail "Possível dado sensível detectado (chaves/senhas/segredos); remova ou redija."
          }

          # Destino obrigatório e válido
          if [ -z "$(printf "%s" "$DEST" | tr -d '[:space:]')" ]; then
            fail "Campo 'Repositório de destino' é obrigatório (formato: owner/repo, URL do GitHub ou apenas repo)."
          else
            CLEAN=$(printf "%s" "$DEST" | tr -d '\r' | sed -E 's#^https?://github\.com/##; s#/$##; s/^[[:space:]]+//; s/[[:space:]]+$//')
            echo "$CLEAN" | grep -Eq '^[[:alnum:]_.-]+(/[[:alnum:]_.-]+)?$' || \
              fail "Repositório de destino inválido; use 'owner/repo' ou link do GitHub."
          fi

          if [ -f precheck_errors.txt ]; then echo "found_errors=true" >> $GITHUB_OUTPUT; else echo "found_errors=false" >> $GITHUB_OUTPUT; fi

      # 4) Comentar reprovação por pré-validação (não fecha)
      - name: Comentar por pré-validação (não fecha)
        if: steps.precheck.outputs.found_errors == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER_REPO: ${{ github.event.repository.full_name }}
          NUM: ${{ github.event.issue.number }}
        run: |
          {
            echo "A solicitação não foi aprovada pela validação automática."
            echo
            echo "**Motivos:**"
            sed 's/^/- /' precheck_errors.txt
            echo
            echo "**Sugestões:**"
            while IFS= read -r m; do
              case "$m" in
                *"ultrapassa 800"*) echo "- Reduza as respostas para no máximo 800 caracteres." ;;
                *"no máximo 2 frases"*) echo "- Reescreva a descrição em até 2 frases com contexto (como/quando ocorreu)." ;;
                *"Localização obrigatória"*) echo "- Informe o caminho/tela. Ex.: Tela principal > Tabuleiro." ;;
                *"Passos para Reprodução"*) echo "- Liste pelo menos 2 passos numerados (1), 2), ...)." ;;
                *"Evidências devem"*) echo "- Inclua ao menos 1 link de print/vídeo ou anexe um arquivo." ;;
                *"Resultado esperado está genérico"*) echo "- Descreva o comportamento correto verificável (ex.: limpar células e resetar o contador)." ;;
                *"dado sensível"*) echo "- Remova chaves/senhas/segredos e substitua por <redigido>." ;;
                *) echo "- $m" ;;
              esac
            done < precheck_errors.txt
          } > body.txt
          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="$(cat body.txt)"

      # 5) Gemini 2.5 Flash (só se passou na pré)
      - name: Validar com Gemini 2.5 Flash (JSON estrito)
        id: gemini
        if: steps.precheck.outputs.found_errors == 'false'
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          set -Eeuo pipefail

          SYS='Você é um revisor de qualidade de bugs. Linguagem: Português (Brasil). Seja objetivo e claro.
          Aprove SOMENTE se TODAS as regras forem atendidas:
          - Título: até 10 palavras (conciso, preserva contexto).
          - Descrição: até 2 frases com contexto (como e quando).
          - Localização: tem ao menos 1 nível.
          - Passos: numerados, pelo menos 2 passos.
          - Evidências: contém ao menos 1 URL ou anexo.
          - Resultado: específico e verificável (não genérico).
          - Sem PII/segredos; se houver -> escalar=true e reprove.
          Não estimar esforço, nem priorizar, nem sugerir solução técnica.
          Responda SOMENTE no schema JSON. Campos "motivos" e "sugestoes" em bullets curtos.
          Se possível, proponha "titulo_corrigido" (<= 10 palavras).'

          USER=$'Descrição do Bug:\n'"${{ steps.parse.outputs.descricao }}"$'\n\nLocalização:\n'"${{ steps.parse.outputs.localizacao }}"$'\n\nPassos para Reprodução:\n'"${{ steps.parse.outputs.passos }}"$'\n\nEvidências:\n'"${{ steps.parse.outputs.evidencias }}"$'\n\nResultado Esperado:\n'"${{ steps.parse.outputs.resultado }}"

          SCHEMA='{"type":"OBJECT","properties":{
            "aprovado":{"type":"BOOLEAN"},
            "escalar":{"type":"BOOLEAN"},
            "score":{"type":"NUMBER"},
            "motivos":{"type":"ARRAY","items":{"type":"STRING"}},
            "sugestoes":{"type":"ARRAY","items":{"type":"STRING"}},
            "titulo_corrigido":{"type":"STRING"}
          },"required":["aprovado","escalar","motivos"]}'

          PAYLOAD=$(jq -n --arg sys "$SYS" --arg user "$USER" --argjson schema "$SCHEMA" \
            '{system_instruction:{role:"system",parts:[{text:$sys}]},
              contents:[{role:"user",parts:[{text:$user}]}],
              generationConfig:{response_mime_type:"application/json",response_schema:$schema,temperature:0.1}}')

          HTTP=$(curl -sS -w "%{http_code}" -o /tmp/resp.json \
            -X POST "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent" \
            -H "Content-Type: application/json" -H "x-goog-api-key: '"$GOOGLE_API_KEY"'" --data-binary "$PAYLOAD")
          echo "HTTP status: $HTTP"
          [ "$HTTP" -ge 200 ] && [ "$HTTP" -lt 300 ] || { echo "Erro:"; cat /tmp/resp.json; exit 1; }

          TEXT=$(jq -r '.candidates[0].content.parts[0].text // empty' /tmp/resp.json)
          [ -z "$TEXT" ] && { echo "Sem texto"; cat /tmp/resp.json; exit 1; }
          echo "$TEXT" | jq . > gemini.json || { echo "$TEXT"; exit 1; }

          APROVADO=$(jq -r '.aprovado' gemini.json)
          ESCALAR=$(jq -r '.escalar' gemini.json)
          TITULO_CORRIGIDO=$(jq -r '.titulo_corrigido // empty' gemini.json)
          [ "$ESCALAR" = "true" ] && APROVADO=false
          echo "aprovado=$APROVADO"   >> $GITHUB_OUTPUT
          echo "titulo_ok=$TITULO_CORRIGIDO" >> $GITHUB_OUTPUT

      # 6) Aprovado: cria issue no repositório de destino
      - name: Criar issue no repositório de destino (se aprovado)
        if: steps.gemini.outputs.aprovado == 'true'
        id: create_issue
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          set -Eeuo pipefail
          RAW_DEST="${{ steps.parse.outputs.destino }}"
          [ -z "${RAW_DEST//[[:space:]]/}" ] && { echo "Destino vazio — não dá para criar a issue no repo alvo." >&2; exit 0; }

          RAW=$(printf "%s" "$RAW_DEST" | tr -d '\r' | sed -E 's#^https?://github\.com/##; s#/$##; s/^[[:space:]]+//; s/[[:space:]]+$//')
          if [[ "$RAW" == */* ]]; then OWNER="${RAW%%/*}"; REPO="${RAW#*/}"; else OWNER="${GITHUB_REPOSITORY%%/*}"; REPO="$RAW"; fi
          [[ "$OWNER" =~ ^[A-Za-z0-9_.-]+$ && "$REPO" =~ ^[A-Za-z0-9_.-]+$ ]] || { echo "Destino inválido após normalização: '$OWNER/$REPO'." >&2; exit 0; }

          echo "Destino resolvido: OWNER='${OWNER}' REPO='${REPO}'"
          gh api -X GET "repos/$OWNER/$REPO" -q .full_name >/dev/null || { echo "Sem acesso a repos/$OWNER/$REPO (ou não existe)." >&2; exit 1; }

          {
            printf "**Descrição do Bug:**\n%s\n\n" '${{ steps.parse.outputs.descricao }}'
            printf "**Localização:**\n%s\n\n"       '${{ steps.parse.outputs.localizacao }}'
            printf "**Passos para Reprodução:**\n%s\n\n" '${{ steps.parse.outputs.passos }}'
            printf "**Evidências:**\n%s\n\n"        '${{ steps.parse.outputs.evidencias }}'
            printf "**Resultado Esperado:**\n%s\n\n" '${{ steps.parse.outputs.resultado }}'
            printf "_Criada automaticamente após aprovação (Gemini 2.5 Flash)._"
          } > body.txt

          TITLE="${{ steps.gemini.outputs.titulo_ok }}"
          [ -z "$TITLE" ] && TITLE="${{ github.event.issue.title }}"

          RESP="$(gh api "repos/$OWNER/$REPO/issues" -f title="$TITLE" -f body="$(cat body.txt)")"
          jq -r '.html_url' <<< "$RESP" > created_url.txt
          echo "url=$(cat created_url.txt)" >> "$GITHUB_OUTPUT"

      # 7) Aprovada: comentar link e mover para Backlog
      - name: Comentar link e mover para Backlog
        if: steps.gemini.outputs.aprovado == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          OWNER_REPO: ${{ github.event.repository.full_name }}
          NUM: ${{ github.event.issue.number }}
          PROJECT_ID: ${{ steps.pitem.outputs.project_id }}
          ITEM_ID: ${{ steps.pitem.outputs.item_id }}
          STATUS_FIELD_ID: ${{ steps.pitem.outputs.status_field_id }}
          BACKLOG_OPT: ${{ steps.pitem.outputs.backlog_opt }}
        run: |
          set -Eeuo pipefail
          url=$(cat created_url.txt)

          {
            echo "✅ Aprovada. Criada no destino:"
            echo "$url"
            echo
            echo "Movendo o item do projeto para **Backlog**."
          } > comment.txt
          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="$(cat comment.txt)"

          gh api graphql -f query='
            mutation($project:ID!, $item:ID!, $field:ID!, $opt:String!){
              updateProjectV2ItemFieldValue(input:{
                projectId:$project, itemId:$item, fieldId:$field,
                value:{ singleSelectOptionId:$opt }
              }){ clientMutationId }
            }' \
            -f project="$PROJECT_ID" -f item="$ITEM_ID" -f field="$STATUS_FIELD_ID" -f opt="$BACKLOG_OPT" >/dev/null

      # 8) Reprovado: comentar (não fecha)
      - name: Comentar (reprovado) — não fecha
        if: steps.precheck.outputs.found_errors == 'false' && steps.gemini.outputs.aprovado != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER_REPO: ${{ github.event.repository.full_name }}
          NUM: ${{ github.event.issue.number }}
        run: |
          jq -r '.motivos[]' gemini.json 2>/dev/null | sed 's/^/- /' > motivos.txt || echo "- Não informado." > motivos.txt
          jq -r '.sugestoes[]' gemini.json 2>/dev/null | sed 's/^/- /' > sugestoes.txt || echo "- Ajuste os campos obrigatórios conforme os motivos." > sugestoes.txt

          {
            echo "A solicitação não foi aprovada pela validação automática."
            echo
            echo "**Motivos:**"; cat motivos.txt
            echo
            echo "**Sugestões:**"; cat sugestoes.txt
          } > body.txt

          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="$(cat body.txt)"
