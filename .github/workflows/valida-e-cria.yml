name: Validar solicitação com Gemini 2.5 Flash e criar issue

on:
  projects_v2_item:
    types: [edited]   # dispara quando um item de Project v2 é editado (p.ex., muda Status)

concurrency:
  group: intake-${{ github.event.projects_v2_item.node_id }}
  cancel-in-progress: true

permissions:
  issues: write
  contents: read
  projects: write   # necessário para ler/atualizar campos do Project v2

jobs:
  gatekeep:
    runs-on: ubuntu-latest
    env:
      GEMINI_MODEL: gemini-2.5-flash

    steps:
      - name: Debug do evento (Projects v2 item)
        run: |
          echo "action: ${{ github.event.action }}"
          echo "item.node_id: ${{ github.event.projects_v2_item.node_id }}"
          echo "project_node_id: ${{ github.event.projects_v2_item.project_node_id }}"

      # Resolve item -> Issue vinculada, Projeto e Status atual
      - name: Carregar item do projeto (issue, projeto, status)
        id: item
        env:
          ITEM_NODE: ${{ github.event.projects_v2_item.node_id }}
        run: |
          set -e
          gh api graphql -f query='
            query($id:ID!){
              node(id:$id){
                ... on ProjectV2Item{
                  id
                  project { id title }
                  content{
                    __typename
                    ... on Issue{
                      id number title body url
                      repository{ nameWithOwner }
                    }
                  }
                  fieldValues(first:50){
                    nodes{
                      __typename
                      ... on ProjectV2ItemFieldSingleSelectValue{
                        name
                        optionId
                        field{ ... on ProjectV2FieldCommon { id name } }
                      }
                    }
                  }
                }
              }
            }' -f id="$ITEM_NODE" > item.json

          PROJ_TITLE=$(jq -r '.data.node.project.title' item.json)
          PROJ_ID=$(jq -r '.data.node.project.id' item.json)
          ITEM_ID=$(jq -r '.data.node.id' item.json)
          STATUS_NAME=$(jq -r '.data.node.fieldValues.nodes[] | select(.field.name=="Status") | .name' item.json)
          STATUS_FIELD_ID=$(jq -r '.data.node.fieldValues.nodes[] | select(.field.name=="Status") | .field.id' item.json)

          ISSUE_REPO=$(jq -r '.data.node.content.repository.nameWithOwner' item.json)
          ISSUE_NUM=$(jq -r '.data.node.content.number' item.json)
          ISSUE_BODY=$(jq -r '.data.node.content.body // empty' item.json)

          echo "Projeto: $PROJ_TITLE"
          echo "Status:  $STATUS_NAME"
          echo "Issue:   $ISSUE_REPO #$ISSUE_NUM"

          # Só seguimos se for o projeto correto e status Triage
          if [ "$PROJ_TITLE" != "projeto-teste" ] || [ "$STATUS_NAME" != "Triage" ]; then
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          {
            echo "proceed=true"
            echo "project_id=$PROJ_ID"
            echo "item_id=$ITEM_ID"
            echo "status_field_id=$STATUS_FIELD_ID"
            echo "issue_repo=$ISSUE_REPO"
            echo "issue_num=$ISSUE_NUM"
          } >> $GITHUB_OUTPUT

          # Passa o body da issue para os próximos passos
          printf "%s" "$ISSUE_BODY" > issue_body.md

      - name: Extrair campos do formulário
        id: parse
        if: steps.item.outputs.proceed == 'true'
        run: |
          BODY=$(cat issue_body.md)

          extrair() {
            echo "$BODY" | awk -v header="### $1" '
              $0==header {flag=1; next}
              /^### / && flag {flag=0}
              flag {print}
            ' | sed "s/^[[:space:]]*//; s/[[:space:]]*$//"
          }

          DESCRICAO=$(extrair "Descrição do Bug")
          LOCALIZACAO=$(extrair "Localização")
          PASSOS=$(extrair "Passos para Reprodução")
          EVIDENCIAS=$(extrair "Evidências")
          RESULTADO=$(extrair "Resultado Esperado")
          DESTINO=$(extrair "Repositório de destino" | head -n 1)

          TITULO=$(printf "%s" "$DESCRICAO" | sed -n '1p' | sed 's/#\+//g; s/\r//g')
          [ -z "$TITULO" ] && TITULO="Bug report"

          {
            echo "descricao<<EOF";   echo "$DESCRICAO";   echo "EOF";
            echo "localizacao<<EOF"; echo "$LOCALIZACAO"; echo "EOF";
            echo "passos<<EOF";      echo "$PASSOS";      echo "EOF";
            echo "evidencias<<EOF";  echo "$EVIDENCIAS";  echo "EOF";
            echo "resultado<<EOF";   echo "$RESULTADO";   echo "EOF";
            echo "destino=$DESTINO";
            echo "titulo=$TITULO";
          } >> $GITHUB_OUTPUT

      # ===================== PRÉ-VALIDAÇÃO (regras objetivas) =====================
      - name: Pré-validação determinística
        id: precheck
        if: steps.item.outputs.proceed == 'true'
        run: |
          fail() { echo "$1" >> precheck_errors.txt; }

          DESC="${{ steps.parse.outputs.descricao }}"
          LOC="${{ steps.parse.outputs.localizacao }}"
          PASS="${{ steps.parse.outputs.passos }}"
          EVID="${{ steps.parse.outputs.evidencias }}"
          RES="${{ steps.parse.outputs.resultado }}"

          TOTLEN=$(printf "%s%s%s%s%s" "$DESC" "$LOC" "$PASS" "$EVID" "$RES" | wc -c)
          [ "$TOTLEN" -gt 450 ] && fail "Texto total ultrapassa 450 caracteres (atual: ${TOTLEN})."

          SENT=$(printf "%s" "$DESC" | tr '\n' ' ' | grep -oE '[.!?]' | wc -l || true)
          [ "$SENT" -gt 2 ] && fail "Descrição do Bug deve ter no máximo 2 frases com contexto (como/quando)."

          [ -z "$(printf "%s" "$LOC" | tr -d '[:space:]')" ] && \
            fail "Localização obrigatória; informe o caminho/tela (ex.: Tela principal > Tabuleiro)."

          CNT=$(printf "%s" "$PASS" | grep -E '^[[:space:]]*[0-9]+[.)]' | wc -l || true)
          [ "$CNT" -lt 2 ] && fail "Passos para Reprodução devem ser numerados (1), 2), ...) e ter no mínimo 2 passos."

          printf "%s" "$EVID" | grep -Eiq '!\[[^]]*\]\(|https?://|\.png|\.jpg|\.jpeg|\.gif|\.mp4|\.mov' || \
            fail "Evidências devem conter ao menos 1 URL (print/vídeo) ou arquivo anexado."

          printf "%s" "$RES" | grep -Eiq 'funcion(a|e) corretamente|sem erro(s)?|deveria funcionar|ok' && \
            fail "Resultado esperado está genérico; descreva comportamento específico e verificável."

          printf "%s %s %s" "$DESC" "$EVID" "$PASS" | \
          grep -Eiq '(AKIA[0-9A-Z]{16}|-----BEGIN (RSA|OPENSSH) PRIVATE KEY-----|password=|secret=|x-api-key|token=|Authorization: Bearer)' && {
            echo "escalar=true" >> $GITHUB_OUTPUT
            fail "Possível dado sensível detectado (chaves/senhas/segredos); remova ou redija."
          }

          if [ -f precheck_errors.txt ]; then
            echo "found_errors=true" >> $GITHUB_OUTPUT
          else
            echo "found_errors=false" >> $GITHUB_OUTPUT
          fi

      - name: Comentar por pré-validação (não fecha)
        if: steps.item.outputs.proceed == 'true' && steps.precheck.outputs.found_errors == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER_REPO: ${{ steps.item.outputs.issue_repo }}
          NUM: ${{ steps.item.outputs.issue_num }}
        run: |
          {
            echo "A solicitação não foi aprovada pela validação automática."
            echo
            echo "**Motivos:**"
            sed 's/^/- /' precheck_errors.txt
            echo
            echo "**Sugestões:**"
            while IFS= read -r m; do
              case "$m" in
                *"ultrapassa 450"* ) echo "- Reduza as respostas para no máximo 450 caracteres." ;;
                *"no máximo 2 frases"* ) echo "- Reescreva a descrição em até 2 frases com contexto (como/quando ocorreu)." ;;
                *"Localização obrigatória"* ) echo "- Informe o caminho/tela. Ex.: Tela principal > Tabuleiro." ;;
                *"Passos para Reprodução"* ) echo "- Liste pelo menos 2 passos numerados (1), 2), ...)." ;;
                *"Evidências devem"* ) echo "- Inclua ao menos 1 link de print/vídeo ou anexe um arquivo." ;;
                *"Resultado esperado está genérico"* ) echo "- Descreva o comportamento correto verificável (ex.: limpar células e resetar o contador)." ;;
                *"dado sensível"* ) echo "- Remova chaves/senhas/segredos e substitua por <redigido>." ;;
                * ) echo "- $m" ;;
              esac
            done < precheck_errors.txt
          } > body.txt

          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="$(cat body.txt)"

      # ===================== GEMINI 2.5 FLASH =====================
      - name: Validar com Gemini 2.5 Flash (JSON estrito)
        id: gemini
        if: steps.item.outputs.proceed == 'true' && steps.precheck.outputs.found_errors == 'false'
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GEMINI_MODEL: ${{ env.GEMINI_MODEL }}
        run: |
          SYS='Você é um revisor de qualidade de bugs. Linguagem: Português (Brasil). Seja objetivo e claro.
          Aprove SOMENTE se TODAS as regras forem atendidas:
          - Título: até 7 palavras (conciso, preserva contexto).
          - Descrição: até 2 frases com contexto (como e quando).
          - Localização: tem ao menos 1 nível.
          - Passos: numerados, pelo menos 2 passos.
          - Evidências: contém ao menos 1 URL ou anexo.
          - Resultado: específico e verificável (não genérico).
          - Sem PII/segredos; se houver -> escalar=true e reprove.
          O que você NAO deve fazer: estimar esforço, priorizar, sugerir solução técnica ou culpados.
          Responda SOMENTE no schema JSON. Preencha "motivos" e "sugestoes" como bullets curtos e diretos.
          Se possível, proponha "titulo_corrigido" (<= 7 palavras).'

          USER=$'Descrição do Bug:\n'"${{ steps.parse.outputs.descricao }}"$'\n\nLocalização:\n'"${{ steps.parse.outputs.localizacao }}"$'\n\nPassos para Reprodução:\n'"${{ steps.parse.outputs.passos }}"$'\n\nEvidências:\n'"${{ steps.parse.outputs.evidencias }}"$'\n\nResultado Esperado:\n'"${{ steps.parse.outputs.resultado }}"

          SCHEMA=$(jq -n '{
            type:"OBJECT",
            properties:{
              aprovado:{type:"BOOLEAN"},
              escalar:{type:"BOOLEAN"},
              score:{type:"NUMBER"},
              motivos:{type:"ARRAY", items:{type:"STRING"}},
              sugestoes:{type:"ARRAY", items:{type:"STRING"}},
              titulo_corrigido:{type:"STRING"}
            },
            required:["aprovado","escalar","motivos"]
          }')

          PAYLOAD=$(jq -n \
            --arg sys "$SYS" \
            --arg user "$USER" \
            --argjson schema "$SCHEMA" \
            '{
              system_instruction:{ role:"system", parts:[{text:$sys}] },
              contents:[ { role:"user", parts:[{text:$user}] } ],
              generationConfig:{
                response_mime_type:"application/json",
                response_schema:$schema,
                temperature:0.1
              }
            }')

          HTTP=$(curl -sS -w "%{http_code}" -o resp.json \
            -X POST "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent" \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GOOGLE_API_KEY" \
            --data-binary "$PAYLOAD")
          echo "HTTP status: $HTTP"
          if [ "$HTTP" -lt 200 ] || [ "$HTTP" -ge 300 ]; then echo "Erro:"; cat resp.json; exit 1; fi

          TEXT=$(jq -r '.candidates[0].content.parts[0].text // empty' resp.json)
          [ -z "$TEXT" ] && { echo "Sem texto"; cat resp.json; exit 1; }
          echo "$TEXT" | jq . > gemini.json || { echo "$TEXT"; exit 1; }

          APROVADO=$(jq -r '.aprovado' gemini.json)
          ESCALAR=$(jq -r '.escalar' gemini.json)
          TITULO_CORRIGIDO=$(jq -r '.titulo_corrigido // empty' gemini.json)
          if [ "$ESCALAR" = "true" ]; then APROVADO=false; fi
          echo "aprovado=$APROVADO" >> $GITHUB_OUTPUT
          echo "titulo_ok=$TITULO_CORRIGIDO" >> $GITHUB_OUTPUT

      # ===================== APROVADO =====================
      - name: Criar issue no repositório de destino (se aprovado)
        if: steps.item.outputs.proceed == 'true' && steps.gemini.outputs.aprovado == 'true'
        id: create_issue
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}   # PAT só para criar no destino
          DEST: ${{ steps.parse.outputs.destino }}
        run: |
          RAW="${{ steps.gemini.outputs.titulo_ok }}"
          [ -z "$RAW" ] || [ "$RAW" = "null" ] && RAW="$(printf "%s" "${{ steps.parse.outputs.titulo }}")"
          TITLE=$(printf "%s\n" "$RAW" | awk '{ n=7; for(i=1;i<=NF && i<=n;i++) printf("%s%s",$i,(i==n||i==NF)?"":" "); print "" }')

          {
            echo "**Descrição do Bug:**"
            echo "${{ steps.parse.outputs.descricao }}"
            echo
            echo "**Localização:**"
            echo "${{ steps.parse.outputs.localizacao }}"
            echo
            echo "**Passos para Reprodução:**"
            echo "${{ steps.parse.outputs.passos }}"
            echo
            echo "**Evidências:**"
            echo "${{ steps.parse.outputs.evidencias }}"
            echo
            echo "**Resultado Esperado:**"
            echo "${{ steps.parse.outputs.resultado }}"
            echo
            echo "_Criada automaticamente após aprovação (Gemini 2.5 Flash)._"
          } > body.txt

          OWNER=${DEST%%/*}
          REPO=${DEST#*/}
          RESP=$(gh api repos/$OWNER/$REPO/issues -f title="$TITLE" -f body="$(cat body.txt)")
          echo "$RESP" | jq -r '.html_url' > created_url.txt
          echo "url=$(cat created_url.txt)" >> $GITHUB_OUTPUT

      - name: Comentar link na issue e mover status para Backlog (projeto-teste)
        if: steps.item.outputs.proceed == 'true' && steps.gemini.outputs.aprovado == 'true'
        env:
          GH_TOKEN: ${{ github.token }}   # comentar e atualizar Project no intake
          OWNER_REPO: ${{ steps.item.outputs.issue_repo }}
          NUM: ${{ steps.item.outputs.issue_num }}
          PROJECT_ID: ${{ steps.item.outputs.project_id }}
          ITEM_ID: ${{ steps.item.outputs.item_id }}
          STATUS_FIELD_ID: ${{ steps.item.outputs.status_field_id }}
        run: |
          url=$(cat created_url.txt)

          # 1) Comenta o link na issue original (no repo de origem)
          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="✅ **Aprovada**. Criada no destino:
${url}

Movendo o item do projeto para **Backlog**."

          # 2) Descobrir optionId de "Backlog" para o campo Status
          gh api graphql -f query='
            query($pid:ID!){
              node(id:$pid){
                ... on ProjectV2{
                  fields(first:100){
                    nodes{
                      ... on ProjectV2SingleSelectField{
                        id name
                        options{ id name }
                      }
                    }
                  }
                }
              }
            }' -f pid="$PROJECT_ID" > fields.json

          STATUS_FIELD_ID_LOCAL="$STATUS_FIELD_ID"
          BACKLOG_OPT=$(jq -r --arg fid "$STATUS_FIELD_ID_LOCAL" '
            .data.node.fields.nodes[]
            | select(.id==$fid)
            | .options[] | select(.name=="Backlog") | .id
          ' fields.json)

          if [ -z "$BACKLOG_OPT" ] || [ "$BACKLOG_OPT" = "null" ]; then
            echo "Não achei optionId para Backlog no campo Status." >&2
            exit 1
          fi

          # 3) Atualiza o Status do item para Backlog
          gh api graphql -f query='
            mutation($project:ID!, $item:ID!, $field:ID!, $opt:ID!){
              updateProjectV2ItemFieldValue(input:{
                projectId:$project,
                itemId:$item,
                fieldId:$field,
                value:{ singleSelectOptionId:$opt }
              }){ clientMutationId }
            }' -f project="$PROJECT_ID" -f item="$ITEM_ID" -f field="$STATUS_FIELD_ID_LOCAL" -f opt="$BACKLOG_OPT" >/dev/null

      # ===================== REPROVADO (NÃO FECHA) =====================
      - name: Comentar (reprovado) — não fecha
        if: steps.item.outputs.proceed == 'true' && steps.gemini.outputs.aprovado != 'true' && steps.precheck.outputs.found_errors == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER_REPO: ${{ steps.item.outputs.issue_repo }}
          NUM: ${{ steps.item.outputs.issue_num }}
        run: |
          jq -r '.motivos[]' gemini.json 2>/dev/null | sed 's/^/- /' > motivos.txt || echo "- Não informado." > motivos.txt
          jq -r '.sugestoes[]' gemini.json 2>/dev/null | sed 's/^/- /' > sugestoes.txt || echo "- Ajuste os campos obrigatórios conforme os motivos." > sugestoes.txt

          {
            echo "A solicitação não foi aprovada pela validação automática."
            echo
            echo "**Motivos:**"
            cat motivos.txt
            echo
            echo "**Sugestões:**"
            cat sugestoes.txt
          } > body.txt

          gh api repos/$OWNER_REPO/issues/$NUM/comments -f body="$(cat body.txt)"
